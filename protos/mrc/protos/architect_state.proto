/**
 * SPDX-FileCopyrightText: Copyright (c) 2021-2022,NVIDIA CORPORATION & AFFILIATES. All rights reserved.
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


syntax = "proto3";

package mrc.protos;

enum ResourceStatus
{
   // Control Plane indicates a resource should be created on the client
   Registered = 0;
   // Client has created resource but it is not ready
   Activated = 1;
   // Client and Control Plane can use the resource
   Ready = 2;
   // Control Plane has indicated the resource should be destroyed on the client. All users of the resource should stop
   // using it and decrement the ref count. Object is still running
   Deactivating = 3;
   // All ref counts have been decremented. Owner of the object on the client can begin destroying object
   Deactivated = 4;
   // Client owner of resource has begun destroying the object
   Unregistered = 5;
   // Object has been destroyed on the client (and may be removed from the server)
   Destroyed = 6;
}

enum SegmentStates
{
   Initialized = 0;
   Running = 1;
   Stopped = 2;
   Completed = 3;
}

message ResourceState {
   // Current status of the resource
   ResourceStatus status = 1;
   // Number of users besides the owner of this resource
   int32 ref_count = 2;
}

message Connection {
   uint64 id = 1;

   // Info about the client (IP/Port)
   string peer_info = 2;

   // Workers that belong to this machine
   repeated uint64 worker_ids = 3;

   // The pipeline instances that are assigned to this machine
   repeated uint64 assigned_pipeline_ids = 4;
}

message Worker {

   uint64 id = 1;

   // Serialized worker address
   bytes worker_address = 2;

   // Parent machine this worker belongs to
   uint64 machine_id = 3;

   // Current state of the worker
   ResourceState state = 4;

   // The segment instances that are assigned to this worker
   repeated uint64 assigned_segment_ids = 5;
}

message PipelineConfiguration{
   message SegmentConfiguration{
      // Name of the segment
      string name = 1;

      // Ingress ports for this segment
      repeated IngressPort ingress_ports = 2;

      // Egress ports for this segment
      repeated EgressPort egress_ports = 3;

      // Segment options
      SegmentOptions options = 4;
   }

   map<string, SegmentConfiguration> segments = 1;
}

enum SegmentMappingPolicies
{
   OnePerWorker = 0;
}

message PipelineMapping {

   message SegmentMapping {

      message ByPolicy {
         // Specify a general policy
         SegmentMappingPolicies value = 1;
      }

      message ByWorker {
         // The workers to assign this segment to
         repeated uint64 worker_ids = 1;
      }

      // The segment definition ID
      string segment_name = 1;

      oneof mapping_type {
         // General policy
         ByPolicy by_policy = 2;

         // Manually specified
         ByWorker by_worker = 3;
      }
  }

   uint64 machine_id = 1;

   map<string, SegmentMapping> segments = 2;
}

message PipelineDefinition {

   message SegmentDefinition{

      // Generated ID of the definition
      uint64 id = 1;

      // ID of the parent for back referencing
      uint64 parent_id = 2;

      // Name of the segment
      string name = 3;

      // Running Segment Instance IDs
      repeated uint64 instance_ids = 4;
   }

   // Generated ID of the definition (int64 because the hash algorithms can give negative values)
   int64 id = 1;

   // Object that holds all of the configurable properties
   PipelineConfiguration config = 2;

   // Machine IDs to mappings for all connections
   map<uint64, PipelineMapping> mappings = 3;

   // Running Pipeline Instance IDs
   repeated uint64 instance_ids = 4;

   // Running Segment Info
   map<string, SegmentDefinition> segments = 5;
}

message PipelineInstance {
   uint64 id = 1;

   // Deinition this belongs to
   int64 definition_id = 2;

   // The machine this instance is running on
   uint64 machine_id = 3;

   // The current state of this resource
   ResourceState state = 4;

   // Running Segment Instance IDs
   repeated uint64 segment_ids = 5;
}

message SegmentDefinition {
   // message Properties{
   //    // Name of the segment
   //    string name = 1;

   //    // Parent Pipeline ID
   //    uint64 pipeline_id = 2;

   //    // Ingress ports for this segment
   //    repeated IngressPort ingress_ports = 3;

   //    // Egress ports for this segment
   //    repeated EgressPort egress_ports = 4;

   //    // Segment options
   //    SegmentOptions options = 5;
   // }

   // Generated ID of the definition
   uint64 id = 1;

   // // Object that holds all of the configurable properties
   // Properties properties = 2;

   // Running Segment Instance IDs
   repeated uint64 instance_ids = 3;
}

message SegmentInstance {
   uint64 id = 1;

   // Pipeline Deinition this belongs to
   int64 pipeline_definition_id = 2;

   // Segment name (Lookup segment config from pipeline def ID and name)
   string name = 3;

   // The encoded address of this instance
   uint32 address = 4;

   // The worker/partition that this belongs to
   uint64 worker_id = 5;

   // The running pipeline instance id
   uint64 pipeline_instance_id = 6;

   // The current state of this resource
   ResourceState state = 7;
}

message ControlPlaneState {
   message ConnectionsState {
      repeated uint64 ids = 1;
      map<uint64, Connection> entities = 2;
   }

   message WorkerssState {
      repeated uint64 ids = 1;
      map<uint64, Worker> entities = 2;
   }

   message PipelineDefinitionsState {
      repeated uint64 ids = 1;
      map<uint64, PipelineDefinition> entities = 2;
   }

   message PipelineInstancesState {
      repeated uint64 ids = 1;
      map<uint64, PipelineInstance> entities = 2;
   }

   message SegmentDefinitionsState {
      repeated uint64 ids = 1;
      map<uint64, SegmentDefinition> entities = 2;
   }

   message SegmentInstancesState {
      repeated uint64 ids = 1;
      map<uint64, SegmentInstance> entities = 2;
   }

   ConnectionsState connections = 1;
   WorkerssState workers = 2;
   PipelineDefinitionsState pipeline_definitions = 3;
   PipelineInstancesState pipeline_instances = 4;
   SegmentDefinitionsState segment_definitions = 5;
   SegmentInstancesState segment_instances = 6;
}


// Below are non top level objects

message SegmentOptions
{
    enum PlacementStrategy
    {
        ResourceGroup = 0;
        PhysicalMachine = 1;
        Global = 2;
    }

    PlacementStrategy placement_strategy = 1;
    ScalingOptions scaling_options = 2;
}

message ScalingOptions
{
    enum ScalingStrategy
    {
        Static = 0;
    }

    ScalingStrategy strategy = 1;
    uint32 initial_count = 2;
}

// for ingress and egress ports
// network_enabled informs the object if data is expected to
// flow in/out of the ports over the network.
// if the value is FALSE, these ports will not be hooked up to
// their respective deserializer/serializer nodes
// AND no architect events will be triggered when on_complete is
// called.
// if the value is TRUE, the ports will be hooked up to the network
// objects AND on_complete will always trigger a blocking architect
// event

message IngressPort
{
    string name = 1;
    uint32 id = 2;
}

message EgressPort
{
    string name = 1;
    uint32 id = 2;

    enum PolicyType
    {
        PolicyDefined = 0;
        UserDefined = 1;
    }

    PolicyType policy_type = 3;
}

message IngressPolicy
{
    bool network_enabled = 1;
}

message EgressPolicy
{
    enum Policy
    {
        LoadBalance = 0;
        Broadcast = 1;
    }
    Policy policy = 3;

    // list of allowed pol
    repeated uint32 segment_addresses = 4; // segment_address, not port_address
}
