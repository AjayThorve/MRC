/**
 * SPDX-FileCopyrightText: Copyright (c) 2021-2022,NVIDIA CORPORATION & AFFILIATES. All rights reserved.
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


syntax = "proto3";

package mrc.protos;

message Connection {
   uint64 id = 1;

   // Info about the client (IP/Port)
   string peer_info = 2;

   // Workers that belong to this machine
   repeated uint64 worker_ids = 3;

   // The pipeline instances that are assigned to this machine
   repeated uint64 assigned_pipeline_ids = 4;
}

enum WorkerStates
{
   Registered = 0;
   Activated = 1;
   Deactivated = 2;
   Destroyed = 3;
}

message Worker {

   uint64 id = 1;

   // Serialized worker address
   bytes worker_address = 2;

   // Parent machine this worker belongs to
   uint64 machine_id = 3;

   // Current state of the worker
   WorkerStates state = 4;

   // The segment instances that are assigned to this worker
   repeated uint64 assigned_segment_ids = 5;
}

message PipelineDefinition {
   uint64 id = 1;

   // Segment Definition IDs
   repeated uint64 segment_ids = 2;

   // Running Pipeline Instance IDs
   repeated uint64 instance_ids = 3;
}

message PipelineInstance {
   uint64 id = 1;

   // Deinition this belongs to
   uint64 definition_id = 2;

   // The machine this instance is running on
   uint64 machine_id = 3;

   // Running Segment Instance IDs
   repeated uint64 segment_ids = 4;
}

message SegmentDefinition {
   uint64 id = 1;

   string name = 2;

   // Parent Pipeline ID
   uint64 pipeline_id = 3;

   // Running Segment Instance IDs
   repeated uint64 instance_ids = 4;

   // Ingress ports for this segment
   repeated IngressPort ingress_ports = 5;

   // Egress ports for this segment
   repeated EgressPort egress_ports = 6;

   // Segment options
   SegmentOptions options = 7;
}

message SegmentInstance {
   uint64 id = 1;

   // The encoded address of this instance
   uint32 address = 2;

   // Deinition this belongs to
   uint64 definition_id = 3;

   // The worker/partition that this belongs to
   uint64 worker_id = 4;

   // The running pipeline instance id
   uint64 pipeline_id = 5;
}

message ControlPlaneState {
   message ConnectionsState {
      repeated uint64 ids = 1;
      map<uint64, Connection> entities = 2;
   }

   message WorkerssState {
      repeated uint64 ids = 1;
      map<uint64, Worker> entities = 2;
   }

   message PipelineDefinitionsState {
      repeated uint64 ids = 1;
      map<uint64, PipelineDefinition> entities = 2;
   }

   message PipelineInstancesState {
      repeated uint64 ids = 1;
      map<uint64, PipelineInstance> entities = 2;
   }

   message SegmentDefinitionsState {
      repeated uint64 ids = 1;
      map<uint64, SegmentDefinition> entities = 2;
   }

   message SegmentInstancesState {
      repeated uint64 ids = 1;
      map<uint64, SegmentInstance> entities = 2;
   }

   ConnectionsState connections = 1;
   WorkerssState workers = 2;
   PipelineDefinitionsState pipeline_definitions = 3;
   PipelineInstancesState pipeline_instances = 4;
   SegmentDefinitionsState segment_definitions = 5;
   SegmentInstancesState segment_instances = 6;
}


// Below are non top level objects

message SegmentOptions
{
    enum PlacementStrategy
    {
        ResourceGroup = 0;
        PhysicalMachine = 1;
        Global = 2;
    }

    PlacementStrategy placement_strategy = 1;
    ScalingOptions scaling_options = 2;
}

message ScalingOptions
{
    enum ScalingStrategy
    {
        Static = 0;
    }

    ScalingStrategy strategy = 1;
    uint32 initial_count = 2;
}

// for ingress and egress ports
// network_enabled informs the object if data is expected to
// flow in/out of the ports over the network.
// if the value is FALSE, these ports will not be hooked up to
// their respective deserializer/serializer nodes
// AND no architect events will be triggered when on_complete is
// called.
// if the value is TRUE, the ports will be hooked up to the network
// objects AND on_complete will always trigger a blocking architect
// event

message IngressPort
{
    string name = 1;
    uint32 id = 2;
}

message EgressPort
{
    string name = 1;
    uint32 id = 2;

    enum PolicyType
    {
        PolicyDefined = 0;
        UserDefined = 1;
    }

    PolicyType policy_type = 3;
}

message IngressPolicy
{
    bool network_enabled = 1;
}

message EgressPolicy
{
    enum Policy
    {
        LoadBalance = 0;
        Broadcast = 1;
    }
    Policy policy = 3;

    // list of allowed pol
    repeated uint32 segment_addresses = 4; // segment_address, not port_address
}
